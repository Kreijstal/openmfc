name: Phase 1 - Extract Symbols

on:
  workflow_dispatch:

jobs:
  extract:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v6

      - name: Setup MSVC (x64)
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64

      - name: Locate MFC files (DLL and import library - x64)
        id: locate
        shell: pwsh
        run: |
          $vswhereExe = Join-Path ${env:ProgramFiles(x86)} "Microsoft Visual Studio\Installer\vswhere.exe"

          function Find-File([string]$name, [string[]]$extraRoots = @()) {
            # First try vswhere
            if (Test-Path $vswhereExe) {
              $vsHits = & $vswhereExe -products * -find "**\$name" 2>$null
              foreach ($h in $vsHits) { if (Test-Path $h) { return Get-Item $h } }
            }
            # Then system paths
            foreach ($p in @("C:\Windows\System32\$name", "C:\Windows\SysWOW64\$name")) {
              if (Test-Path $p) { return Get-Item $p }
            }
            # Then VS/VC directories
            $roots = @(
              $env:VCToolsRedistDir,
              $env:VCToolsInstallDir,
              $env:VSINSTALLDIR,
              'C:\Program Files\Microsoft Visual Studio',
              'C:\Program Files (x86)\Microsoft Visual Studio'
            ) + $extraRoots | Where-Object { $_ -and (Test-Path $_) }
            foreach ($root in $roots) {
              Write-Host "Searching $root for $name"
              $hit = Get-ChildItem -Path $root -Filter $name -Recurse -ErrorAction SilentlyContinue -File | Select-Object -First 1
              if ($hit) { return $hit }
            }
            return $null
          }

          # Find the DLL (for version info and hash)
          $mfcDll = Find-File -name 'mfc140u.dll'
          if (-not $mfcDll) { Write-Error "mfc140u.dll not found"; exit 1 }
          Write-Host "Found DLL: $($mfcDll.FullName)"

          # Find the import library (for symbol names - MFC exports by ordinal only!)
          # IMPORTANT: Must use x64 version for 64-bit symbol names
          $mfcLibPath = Join-Path $env:VCToolsInstallDir "ATLMFC\lib\x64\mfc140u.lib"
          if (-not (Test-Path $mfcLibPath)) {
            # Fallback to search
            $mfcLib = Find-File -name 'mfc140u.lib'
            if (-not $mfcLib) { Write-Error "mfc140u.lib not found"; exit 1 }
            $mfcLibPath = $mfcLib.FullName
          }
          Write-Host "Found LIB: $mfcLibPath"

          # Verify it's x64 by checking for x64 symbol patterns
          $testDump = & dumpbin /nologo /SYMBOLS $mfcLibPath 2>$null | Select-String "@@QEAA" | Select-Object -First 1
          if (-not $testDump) {
            Write-Warning "Library may not be x64 - checking for x86 patterns..."
            $x86Test = & dumpbin /nologo /SYMBOLS $mfcLibPath 2>$null | Select-String "@@QAA" | Select-Object -First 1
            if ($x86Test) {
              Write-Error "Found x86 library instead of x64! Path: $mfcLibPath"
              exit 1
            }
          }
          Write-Host "Verified x64 library"

          "mfc_dll=$($mfcDll.FullName)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "mfc_lib=$mfcLibPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Dump symbols from import library
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path artifacts | Out-Null

          # Dump from import library to get symbol names (DLL only has ordinals)
          # Use /SYMBOLS to get the symbol table from the .lib file
          $libPath = '${{ steps.locate.outputs.mfc_lib }}'
          Write-Host "Dumping symbols from: $libPath"
          & dumpbin /nologo /SYMBOLS $libPath | Out-File -FilePath artifacts/mfc_lib_symbols.txt -Encoding ASCII

          # Also dump archive members to get import thunks
          & dumpbin /nologo /ARCHIVEMEMBERS $libPath | Out-File -FilePath artifacts/mfc_lib_members.txt -Encoding ASCII

          # Dump ALL information from .lib file
          & dumpbin /nologo /ALL $libPath | Out-File -FilePath artifacts/mfc_lib_all.txt -Encoding ASCII

          # Also dump exports from DLL for reference (will show ordinals only)
          $dllPath = '${{ steps.locate.outputs.mfc_dll }}'
          & dumpbin /nologo /exports $dllPath | Out-File -FilePath artifacts/mfc.exports -Encoding ASCII

          # Copy the actual .lib file for offline analysis
          Copy-Item $libPath artifacts/mfc140u.lib

      - name: Extract and demangle symbol names
        shell: pwsh
        run: |
          $symbolsFile = "artifacts/mfc_lib_symbols.txt"
          $outSymbols = "artifacts/mfc_symbols.txt"
          $outDemangled = "artifacts/demangled.txt"

          # Parse symbol dump to extract mangled names
          # We need to extract PRIMARY symbols (External) not aliases (WeakExternal)
          $symbols = @()
          Get-Content $symbolsFile | ForEach-Object {
            $line = $_
            # Check if line contains "External" but NOT "WeakExternal"
            if ($line -match 'External' -and $line -notmatch 'WeakExternal') {
              # Match symbol after pipe character
              if ($line -match '\|\s+(\?[^\s]+)') {
                $symbol = $Matches[1]
                # Remove __imp_ prefix if present
                if ($symbol -match '^__imp_') {
                  $symbol = $symbol -replace '^__imp_', ''
                }
                $symbols += $symbol
              }
            }
          }

          # Deduplicate and sort
          $symbols = $symbols | Sort-Object -Unique
          Write-Host "Found $($symbols.Count) unique symbols"

          # Write raw symbols
          $symbols | Out-File -FilePath $outSymbols -Encoding ASCII

          # Demangle each symbol
          Remove-Item -ErrorAction SilentlyContinue $outDemangled
          foreach ($sym in $symbols) {
            $pretty = (& undname.exe $sym 2>$null) -join ' '
            if ($pretty) {
              "$sym => $pretty" | Out-File -FilePath $outDemangled -Append -Encoding ASCII
            }
          }

          Write-Host "Wrote $($symbols.Count) symbols to $outSymbols"

      - name: Metadata and hash
        shell: pwsh
        run: |
          $meta = @{}
          $dllPath = '${{ steps.locate.outputs.mfc_dll }}'
          $meta.mfc_version = (Get-Item $dllPath).VersionInfo.ProductVersion
          $meta.vs_version = $env:VisualStudioVersion
          $meta.sha256_mfc140u = (Get-FileHash $dllPath -Algorithm SHA256).Hash.ToLower()
          $json = ($meta | ConvertTo-Json -Depth 4)
          $json | Out-File -FilePath artifacts/metadata.json -Encoding ASCII

      - name: Extract ordinal mappings
        shell: bash
        run: |
          # Extract symbolâ†’ordinal mappings from dumpbin /ALL output
          # Use our Python script
          python tools/extract_ordinals.py \
            --dumpbin artifacts/mfc_lib_all.txt \
            --out-symbols artifacts/mfc_symbols_corrected.txt \
            --out-json artifacts/ordinal_map.json

          echo "Extracted ordinal mappings"

      - name: Generate mfc_db.json
        shell: bash
        run: |
          python tools/parse_exports.py \
            --dll mfc140u \
            --exports artifacts/mfc.exports \
            --symbols artifacts/mfc_symbols.txt \
            --demangled artifacts/demangled.txt \
            --ordinal-map artifacts/ordinal_map.json \
            --metadata artifacts/metadata.json \
            --out artifacts/mfc_db.json

      - name: Upload artifacts
        uses: actions/upload-artifact@v6
        with:
          name: phase1_exports
          path: artifacts/
          retention-days: 14