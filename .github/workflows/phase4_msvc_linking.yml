name: Phase 4 - MSVC Linking Test

on:
  push:
    branches: [phase4-*, master]
  pull_request:
    branches: [master]
  workflow_dispatch:

jobs:
  build-phase4-mingw:
    runs-on: ubuntu-latest
    outputs:
      dll-artifact: ${{ steps.upload.outputs.artifact-name }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Install MinGW
      run: sudo apt-get update && sudo apt-get install -y mingw-w64
    
    - name: Build Phase 4
      run: |
        ./phase4/scripts/build_phase4.sh
        ls -la build-phase4/
    
    - name: Upload Phase 4 artifacts
      id: upload
      uses: actions/upload-artifact@v6
      with:
        name: phase4-openmfc
        path: |
          build-phase4/openmfc.dll
          build-phase4/openmfc.def
          build-phase4/libopenmfc.a
        retention-days: 7
  
  test-msvc-linking:
    runs-on: windows-latest
    needs: build-phase4-mingw
    timeout-minutes: 20
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Download Phase 4 artifacts
      uses: actions/download-artifact@v4
      with:
        name: phase4-openmfc
        path: phase4-artifacts
    
    - name: Setup MSVC
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: x64

    - name: Create MSVC import library
      shell: cmd
      run: |
        echo Creating MSVC import library from .def file...
        lib /DEF:phase4-artifacts\openmfc.def /OUT:openmfc.lib /MACHINE:X64
        if %ERRORLEVEL% neq 0 (
          echo Failed to create MSVC import library
          exit /b 1
        )
        echo Successfully created openmfc.lib
    
    - name: Build MSVC test app
      shell: cmd
      run: |
        echo Building MSVC test application...
        cl.exe /nologo /EHsc /std:c++17 /I include /D_AFXDLL /DOPENMFC_APPCORE_IMPL /Fe:test_msvc_linking.exe tests\test_msvc_app.cpp openmfc.lib user32.lib
        if %ERRORLEVEL% neq 0 (
          echo Failed to build MSVC test app
          exit /b 1
        )
        echo Successfully built test_msvc_linking.exe
    
    - name: Build Hello World test
      shell: cmd
      run: |
        echo Building Hello World test application...
        cl.exe /nologo /EHsc /std:c++17 /MD /D_AFXDLL /I include /Fe:test_hello_world.exe phase4\tests\test_hello_world.cpp openmfc.lib user32.lib
        if %ERRORLEVEL% neq 0 (
          echo Failed to build Hello World test app
          exit /b 1
        )
        echo Successfully built test_hello_world.exe
    
    - name: Run MSVC linking test
      shell: pwsh
      run: |
        echo "Running MSVC linking test..."
        Copy-Item phase4-artifacts\openmfc.dll .
        
        $output = & .\test_msvc_linking.exe 2>&1 | Out-String
        Write-Host $output
        
        if ($LASTEXITCODE -eq 0) {
          Write-Host "✅ MSVC linking test passed!"
        } else {
          Write-Host "❌ MSVC linking test failed"
          exit 1
        }
    
    - name: Run Hello World test
      shell: pwsh
      run: |
        echo "Running Hello World test..."
        Copy-Item phase4-artifacts\openmfc.dll .

        $timeoutSeconds = 30
        $stdoutPath = "hello_world_stdout.txt"
        $stderrPath = "hello_world_stderr.txt"

        # Start the test process
        $proc = Start-Process -FilePath ".\\test_hello_world.exe" -PassThru -RedirectStandardOutput $stdoutPath -RedirectStandardError $stderrPath

        # Background job to find and click the MessageBox
        $clickerJob = Start-Job -ScriptBlock {
          Add-Type @"
            using System;
            using System.Runtime.InteropServices;
            public class Win32 {
              [DllImport("user32.dll", SetLastError = true)]
              public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
              [DllImport("user32.dll", CharSet = CharSet.Auto)]
              public static extern int GetWindowText(IntPtr hWnd, System.Text.StringBuilder lpString, int nMaxCount);
              [DllImport("user32.dll")]
              public static extern bool PostMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);
              [DllImport("user32.dll")]
              public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow);
            }
        "@
          $WM_CLOSE = 0x0010
          $BM_CLICK = 0x00F5

          for ($i = 0; $i -lt 60; $i++) {
            Start-Sleep -Milliseconds 500
            # Find MessageBox by title
            $hwnd = [Win32]::FindWindow("#32770", "OpenMFC Hello World")
            if ($hwnd -ne [IntPtr]::Zero) {
              # Found it! Get the text to verify
              $sb = New-Object System.Text.StringBuilder 512
              [Win32]::GetWindowText($hwnd, $sb, $sb.Capacity) | Out-Null
              Write-Host "Found MessageBox: '$($sb.ToString())'"

              # Find OK button and click it
              $btnHwnd = [Win32]::FindWindowEx($hwnd, [IntPtr]::Zero, "Button", "OK")
              if ($btnHwnd -ne [IntPtr]::Zero) {
                Write-Host "Clicking OK button..."
                [Win32]::PostMessage($btnHwnd, $BM_CLICK, [IntPtr]::Zero, [IntPtr]::Zero) | Out-Null
                return "OK"
              } else {
                # Fallback: close the window
                Write-Host "No OK button found, closing window..."
                [Win32]::PostMessage($hwnd, $WM_CLOSE, [IntPtr]::Zero, [IntPtr]::Zero) | Out-Null
                return "CLOSED"
              }
            }
          }
          return "NOT_FOUND"
        }

        # Wait for the process to complete
        Wait-Process -Id $proc.Id -Timeout $timeoutSeconds -ErrorAction SilentlyContinue
        $proc.Refresh()

        # Get clicker job result
        $clickerResult = Receive-Job -Job $clickerJob -Wait -AutoRemoveJob -ErrorAction SilentlyContinue
        Write-Host "Clicker result: $clickerResult"

        if (-not $proc.HasExited) {
          Write-Host "❌ Hello World test timed out after ${timeoutSeconds}s; terminating process."
          Stop-Process -Id $proc.Id -Force -ErrorAction SilentlyContinue
          if (Test-Path $stdoutPath) { Get-Content $stdoutPath -Raw | Write-Host }
          if (Test-Path $stderrPath) { Get-Content $stderrPath -Raw | Write-Host }
          exit 1
        }

        if (Test-Path $stdoutPath) { Get-Content $stdoutPath -Raw | Write-Host }
        if (Test-Path $stderrPath) { Get-Content $stderrPath -Raw | Write-Host }

        if ($proc.ExitCode -eq 0) {
          Write-Host "✅ Hello World test passed!"
        } else {
          Write-Host "❌ Hello World test failed with exit code $($proc.ExitCode)"
          exit 1
        }

    - name: Upload Hello World artifact
      uses: actions/upload-artifact@v6
      if: always()
      with:
        name: phase4-hello-world
        path: |
          test_hello_world.exe
          openmfc.dll
        retention-days: 7

    - name: Run comprehensive test
      shell: pwsh
      run: |
        echo "Running MinGW comprehensive test (ordinal-only import lib -> MSVC exports)..."
        # Install MinGW on Windows runner
        choco install mingw -y
        
        # Avoid `refreshenv` (it uses `wmic`, which is missing on newer runners).
        # Instead, prepend the known MinGW bin locations.
        $mingwBins = @(
          "C:\\ProgramData\\mingw64\\mingw64\\bin",
          "C:\\ProgramData\\chocolatey\\lib\\mingw\\tools\\install\\mingw64\\bin"
        )
        foreach ($p in $mingwBins) {
          if (Test-Path $p) { $env:Path = "$p;$env:Path" }
        }

        $dlltool = (Get-Command dlltool.exe -ErrorAction SilentlyContinue).Source
        if (-not $dlltool) { $dlltool = (Get-Command x86_64-w64-mingw32-dlltool.exe -ErrorAction SilentlyContinue).Source }
        $gpp = (Get-Command g++.exe -ErrorAction SilentlyContinue).Source
        if (-not $dlltool -or -not $gpp) {
          Write-Host "MinGW toolchain not found on PATH"
          exit 1
        }

        # Build an import library that imports by ordinal only. This avoids:
        # - embedding MSVC-mangled names (`?Foo@@...`) into MinGW object files
        # - relying on dlltool "alias name" mapping, which still imports by name
        #
        # We read ordinals from the produced openmfc.def so the test tracks the
        # repo's canonical mapping.
        $defPath = "phase4-artifacts\\openmfc.def"
        if (-not (Test-Path $defPath)) {
          Write-Host "Missing def file: $defPath"
          exit 1
        }

        function Get-Ordinal([string]$symbol) {
          $hit = Select-String -Path $defPath -Pattern ([regex]::Escape($symbol)) | Select-Object -First 1
          if (-not $hit) { throw "Symbol not found in def: $symbol" }
          if ($hit.Line -match "@(\d+)") { return [int]$matches[1] }
          throw "No ordinal found in def line: $($hit.Line)"
        }

        $ordAfxGetDllVersion = Get-Ordinal "?AfxGetDllVersion@@YAKXZ"
        $ordAfxGetThread     = Get-Ordinal "?AfxGetThread@@YAPEAVCWinThread@@XZ"
        $ordOpNew            = Get-Ordinal "??2@YAPEAX_K@Z"
        $ordOpDelete         = Get-Ordinal "??3@YAXPEAX@Z"

        @"
        LIBRARY openmfc.dll
        EXPORTS
          AfxGetDllVersion @$ordAfxGetDllVersion NONAME
          AfxGetThread @$ordAfxGetThread NONAME
          mfc_operator_new @$ordOpNew NONAME
          mfc_operator_delete @$ordOpDelete NONAME
        "@ | Out-File -Encoding ASCII openmfc_ordinal_imports.def

        & $dlltool -d openmfc_ordinal_imports.def -l openmfc_ordinal_imports.a
        if ($LASTEXITCODE -ne 0) {
          Write-Host "Failed to create ordinal import library"
          exit 1
        }

        # Build the test (normal link; no GetProcAddress)
        & $gpp -std=c++17 -O2 -o test_comprehensive.exe tests\\test_mingw_msvc_mangled_imports.cpp openmfc_ordinal_imports.a
        
        if ($LASTEXITCODE -ne 0) {
          Write-Host "Failed to build comprehensive test"
          exit 1
        }
        
        # Run the test
        Copy-Item phase4-artifacts\openmfc.dll .
        $output = & .\test_comprehensive.exe 2>&1 | Out-String
        Write-Host $output
        
        if ($LASTEXITCODE -eq 0) {
          Write-Host "✅ Comprehensive test passed!"
        } else {
          Write-Host "❌ Comprehensive test failed"
          exit 1
        }
